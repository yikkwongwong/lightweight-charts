"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5495],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>f});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=i.createContext({}),l=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=l(e.components);return i.createElement(p.Provider,{value:n},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=l(t),u=r,f=c["".concat(p,".").concat(u)]||c[u]||h[u]||a;return t?i.createElement(f,o(o({ref:n},d),{},{components:t})):i.createElement(f,o({ref:n},d))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=u;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<a;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},26876:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var i=t(87462),r=(t(67294),t(3905));const a={sidebar_position:0,sidebar_label:"Pixel Perfect Rendering",pagination_title:"Pixel Perfect Rendering",title:"Best Practices for Pixel Perfect Rendering in Canvas Drawings",description:"Best Practices for Pixel Perfect Rendering in Canvas Drawings when creating plugins for the Lightweight Charts",keywords:["plugins","extensions","rendering","canvas","bitmap","media","pixels"],pagination_prev:null},o=void 0,s={unversionedId:"plugins/pixel-perfect-rendering/index",id:"plugins/pixel-perfect-rendering/index",title:"Best Practices for Pixel Perfect Rendering in Canvas Drawings",description:"Best Practices for Pixel Perfect Rendering in Canvas Drawings when creating plugins for the Lightweight Charts",source:"@site/docs/plugins/pixel-perfect-rendering/index.md",sourceDirName:"plugins/pixel-perfect-rendering",slug:"/plugins/pixel-perfect-rendering/",permalink:"/lightweight-charts/docs/next/plugins/pixel-perfect-rendering/",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,sidebar_label:"Pixel Perfect Rendering",pagination_title:"Pixel Perfect Rendering",title:"Best Practices for Pixel Perfect Rendering in Canvas Drawings",description:"Best Practices for Pixel Perfect Rendering in Canvas Drawings when creating plugins for the Lightweight Charts",keywords:["plugins","extensions","rendering","canvas","bitmap","media","pixels"],pagination_prev:null},sidebar:"docsSidebar",next:{title:"Candlesticks",permalink:"/lightweight-charts/docs/next/plugins/pixel-perfect-rendering/widths/candlestick"}},p={},l=[{value:"Centered Shapes",id:"centered-shapes",level:2},{value:"Dual Point Shapes",id:"dual-point-shapes",level:2},{value:"Default Widths",id:"default-widths",level:2}],d={toc:l},c="wrapper";function h(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"To achieve crisp pixel perfect rendering for your plugins, it is recommended that the canvas drawings are created using bitmap coordinates. The difference between media and bitmap coordinate spaces is discussed on the ",(0,r.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/next/plugins/canvas-rendering-target"},"Canvas Rendering Target")," page. ",(0,r.kt)("strong",{parentName:"p"},"Essentially, all drawing actions should use integer positions and dimensions when on the bitmap coordinate space.")),(0,r.kt)("p",null,"To ensure consistency between your plugins and the library's built-in logic for rendering points on the chart, use of the following calculation functions."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Variable names containing ",(0,r.kt)("inlineCode",{parentName:"p"},"media")," refer to positions / dimensions specified using the media coordinate space (such as the x and y coordinates provided by the library to the renderers), and names containing ",(0,r.kt)("inlineCode",{parentName:"p"},"bitmap")," refer to positions / dimensions on the bitmap coordinate space (actual device screen pixels).")),(0,r.kt)("h2",{id:"centered-shapes"},"Centered Shapes"),(0,r.kt)("p",null,"If you need to draw a shape which is centred on a position (for example a price or x coordinate) and has a desired width then you could use the ",(0,r.kt)("inlineCode",{parentName:"p"},"positionsLine")," function presented below. This can be used for drawing a horizontal line at a specific price, or a vertical line aligned with the centre of series point."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface BitmapPositionLength {\n    /** coordinate for use with a bitmap rendering scope */\n    position: number;\n    /** length for use with a bitmap rendering scope */\n    length: number;\n}\n\nfunction centreOffset(lineBitmapWidth: number): number {\n    return Math.floor(lineBitmapWidth * 0.5);\n}\n\n/**\n * Calculates the bitmap position for an item with a desired length (height or width), and centred according to\n * a position coordinate defined in media sizing.\n * @param positionMedia - position coordinate for the bar (in media coordinates)\n * @param pixelRatio - pixel ratio. Either horizontal for x positions, or vertical for y positions\n * @param desiredWidthMedia - desired width (in media coordinates)\n * @returns Position of the start point and length dimension.\n */\nexport function positionsLine(\n    positionMedia: number,\n    pixelRatio: number,\n    desiredWidthMedia: number = 1,\n    widthIsBitmap?: boolean\n): BitmapPositionLength {\n    const scaledPosition = Math.round(pixelRatio * positionMedia);\n    const lineBitmapWidth = widthIsBitmap\n        ? desiredWidthMedia\n        : Math.round(desiredWidthMedia * pixelRatio);\n    const offset = centreOffset(lineBitmapWidth);\n    const position = scaledPosition - offset;\n    return { position, length: lineBitmapWidth };\n}\n")),(0,r.kt)("h2",{id:"dual-point-shapes"},"Dual Point Shapes"),(0,r.kt)("p",null,"If you need to draw a shape between two coordinates (for example, y coordinates for a high and low price) then you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"positionsBox")," function as presented below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Determines the bitmap position and length for a dimension of a shape to be drawn.\n * @param position1Media - media coordinate for the first point\n * @param position2Media - media coordinate for the second point\n * @param pixelRatio - pixel ratio for the corresponding axis (vertical or horizontal)\n * @returns Position of the start point and length dimension.\n */\nexport function positionsBox(\n    position1Media: number,\n    position2Media: number,\n    pixelRatio: number\n): BitmapPositionLength {\n    const scaledPosition1 = Math.round(pixelRatio * position1Media);\n    const scaledPosition2 = Math.round(pixelRatio * position2Media);\n    return {\n        position: Math.min(scaledPosition1, scaledPosition2),\n        length: Math.abs(scaledPosition2 - scaledPosition1) + 1,\n    };\n}\n")),(0,r.kt)("h2",{id:"default-widths"},"Default Widths"),(0,r.kt)("p",null,"Please refer to the following pages for functions defining the default widths of shapes drawn by the library:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/lightweight-charts/docs/next/plugins/pixel-perfect-rendering/widths/crosshair"},"Crosshair and Grid Lines")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/lightweight-charts/docs/next/plugins/pixel-perfect-rendering/widths/candlestick"},"Candlesticks")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/lightweight-charts/docs/next/plugins/pixel-perfect-rendering/widths/columns"},"Columns (Histogram)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/lightweight-charts/docs/next/plugins/pixel-perfect-rendering/widths/full-bar-width"},"Full Bar Width"))))}h.isMDXComponent=!0}}]);